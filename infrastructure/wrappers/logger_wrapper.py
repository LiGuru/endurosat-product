class WrapperMethodLogger:    def __init__(self, cls):        self.cls = cls        self.slogger = None    def __call__(self, *args, **kwargs):        if self.slogger is None:            self.slogger = kwargs.get("slogger")  # Проверете дали 'slogger' е предоставен            if self.slogger is None:                raise ValueError("slogger not provided")        class WrappedClass(self.cls):            def __init__(self, *args, **kwargs):                super().__init__(*args, **kwargs)            def __getattribute__(self, attr):                try:                    method = super().__getattribute__(attr)                except AttributeError:                    return super().__getattribute__(attr)                if callable(method) and not attr.startswith('__'):                    def wrapped_method(*args, **kwargs):                        self.slogger.debug(                            f'Call method {attr} of {self.__class__.__name__} '                            f'{"with" if args or kwargs else "-> None"} '                            f'{args if args else ""} {kwargs if kwargs else ""}')                        result = method(*args, **kwargs)                        self.slogger.debug(f'Method {attr} returned {result}')                        return result                    return wrapped_method                return method        return WrappedClass